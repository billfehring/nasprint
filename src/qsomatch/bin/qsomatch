#!/usr/bin/env ruby

require 'getoptlong'
require 'database'
require 'contestdb'
require 'callsign'
require 'addlog'
require 'cabrillo'
require 'qrzdb'
require 'crossmatch'
require 'singletons'
require 'calctimeadj'
require 'multiplier'
require 'report'
require 'errors'
require 'dumplog'


$year = nil
$name = nil
$explain = false
$totallydestroy = false
$restart = false
$create = false
$readinit = true
$action = nil
$qrzuser = nil
$qrzpwd = nil
$verbose = nil
ct = CallsignTools.new

opts = GetoptLong.new(
                      [ '--new', '-N', GetoptLong::NO_ARGUMENT],
                      [ '--check', '-C', GetoptLong::NO_ARGUMENT],
                      [ '--check-dupe', '-c', GetoptLong::NO_ARGUMENT],
                      [ '--no-init', '-I', GetoptLong::NO_ARGUMENT],
                      [ '--qrzuser', '-u', GetoptLong::REQUIRED_ARGUMENT],
                      [ '--exceptions', '-X', GetoptLong::REQUIRED_ARGUMENT],
                      [ '--qrzpwd', '-p', GetoptLong::REQUIRED_ARGUMENT],
                      [ '--sqlite', '-S', GetoptLong::REQUIRED_ARGUMENT],
                      [ '--reset', '-R', GetoptLong::NO_ARGUMENT],
                      [ '--name', '-n', GetoptLong::REQUIRED_ARGUMENT],
                      [ '--year', '-y', GetoptLong::REQUIRED_ARGUMENT],
                      [ '--verbose', '-V', GetoptLong::NO_ARGUMENT],
                      [ '--load', '-l', GetoptLong::NO_ARGUMENT],
                      [ '--score', '-s', GetoptLong::NO_ARGUMENT]
                      )

cmddbopts = Hash.new
opts.each { |opt, arg|
  case opt
  when '--new'
    $create = true
  when '--no-init'
    $readinit = false
  when '--qrzuser'
    $qrzuser = arg
  when '--verbose'
    $verbose = true
  when '--qrzpwd'
    $qrzpwd = arg
  when '--sqlite'
    cmddbopts['type'] = 'sqlite3'
    cmddbopts['filename'] = arg
  when '--check'
    $action = :check
  when '--check-dupe'
    $action = :checkdupes
  when '--load'
    $action = :load
  when '--score'
    $action = :score
  when '--reset'
    $restart = true
  when '--name'
    $name = arg
  when '--year'
    $year = arg.to_i
  when '--exceptions'
    ct.addException(arg.split(/[,;:]/))
  end
}
                      

if $readinit and ENV["HOME"] and File.readable?(ENV["HOME"] + File::SEPARATOR + ".qsomatch")
  require 'json'
  dbopts = JSON.load(File.read(ENV["HOME"] + File::SEPARATOR + ".qsomatch"))
else
  dbopts = { 'type' => 'sqlite3', 'filename' => 'qsomatch.db' }
end

dbopts.merge!(cmddbopts)

def loadFiles(args, cdb, contestID, ct)
  args.each { |filename|
    begin
      cab = Cabrillo.new(filename)
      if cab and cdb
        addLog(cdb, contestID, cab, ct)
      end
      if $action == :check
        if cab
          if not cab.cleanparse
            $stderr.flush
            print "Station: #{cab.logcall}:#{filename} failed to parse.\n"
            $stdout.flush
          end
          if not cab.badmults.empty?
            $stderr.flush
            print "Station: #{cab.logcall}:#{filename} has bad #{cab.badmults.size} multipliers in #{cab.qsos.size} QSO(s).\n"
            print "Multipliers: " + cab.badmults.to_a.join(" ") + "\n"
            $stdout.flush
          end
          if not cab.defaultSentQTH  or cab.defaultSentQTH == "CA"
            print "Station: #{cab.logcall}:#{filename} has bad sent QTH #{cab.defaultSentQTH}\n"
          end
        else
          $stderr.flush
          print "#{filename} failed to parse at all.\n"
          $stdout.flush
        end
      end
    rescue ArgumentError => e
      $stderr.flush
      print "#{filename} caused an exception #{e}\n"
      $stdout.flush
    end
  }
  if cdb
    cdb.checkDupeLogs(contestID)
  end
end

def checkCallsigns(db, cid, user, pwd)
  if user and pwd
    qrz = QRZLookup.new(user, pwd)
  else
    qrz = nil
  end
  xmldb = readXMLDb()
  res = db.query("select id, basecall from Callsign where contestID = ? and validcall is null;", [cid.to_i])
  res.each { |row|
    if xmldb.has_key?(row[1]) 
      db.query("update Callsign set validcall = ? where id = ? limit 1;",
               [(xmldb[row[1]] ? 1 : 0), row[0].to_i])
    elsif lookupCall(qrz, xmldb, row[1])
      db.query("update Callsign set validcall = 1 where id = ? limit 1;",
               [row[0].to_i])
    else
      db.query("update Callsign set validcall = 0 where id = ? limit 1;",
               [row[0].to_i]);
      print "Callsign #{row[1]} is unknown to QRZ.\n"
    end
  }
end

NUMSECS=5
NUMDOTS=3
def restartContest(cm)
  print "Restarting in 5 seconds: "
  NUMSECS.times { |i|
    print (NUMSECS-i).to_s
    NUMDOTS.times { 
      sleep (1.0/NUMDOTS)
      print "."
      $stdout.flush
    }
  }
  print "0  Done.\n"
  $stdout.flush
  cm.restartMatch
end


def scoreContest(db, contestID, contestDB)
  cm = CrossMatch.new(db, contestID, contestDB)
  if $restart
    restartContest(cm)
  end
  checkCallsigns(db, contestID, $qrzuser, $qrzpwd)
  num1 = cm.perfectMatch
  print "Perfect matches: #{num1}\n"
  $stdout.flush
  num1 = cm.perfectMatch(CrossMatch::PERFECT_TIME_MATCH,
                         "Partial", 
                         false)
  print "Perfect matches (with a band or mode mismatch): #{num1}\n"
  num3, partial = cm.partialMatch
  print "Full matches partial: #{num3}\n"
  print "Partial matches full: #{partial}\n"
  $stdout.flush
  num1 = cm.perfectMatch(CrossMatch::MAXIMUM_TIME_MATCH, 'TimeShiftFull')
  print "Time shifted perfect matches: #{num1}\n"
  $stdout.flush
  num3, partial = cm.partialMatch(CrossMatch::MAXIMUM_TIME_MATCH, 'TimeShiftFull', 'TimeShiftPartial')
  print "Time shifted full matches partial: #{num3}\n"
  print "Time shifted partial matches full: #{partial}\n"
  $stdout.flush
  num3, partial = cm.partialMatch(CrossMatch::PERFECT_TIME_MATCH,
                                  'Partial', 'Partial',
                                  false)
  print "One side match with band/mode mismatch: #{num3}\n"
  print "One size mismatch with band/mode mismatch: #{partial}\n"
  $stdout.flush
  p1, p2 = cm.basicMatch(CrossMatch::MAXIMUM_TIME_MATCH)
  print "Basic QSO matches within 24 hours: #{p1+p2}\n"
  $stdout.flush
#   cm.probMatch
  print "Calculating clock drift\n"
  ct = CalcTimeAdj.new(db, contestID)
  ct.buildVariables
  ct.buildMatrix
  return  # warning short circuit end
  timeviolation = ct.markOutOfContest
  print "QSOs outside contest time period: #{timeviolation}\n"
  $stdout.flush
  num1, num2 = cm.resolveShifted
  print "Time shift resolved #{num1} full and #{num2} partial\n"
  $stdout.flush
  d1 = cm.ignoreDups
  print "Duplicates of matches: #{d1}\n"
  ct = nil
  nil1 = cm.markNIL
  print "Not In Log penalties: #{nil1}\n"
  singles = ResolveSingletons.new(db, contestID, contestDB)
  print "Resolving singletons\n"
  $stdout.flush
  singles.resolve
  num = singles.finalDupeCheck
  print "#{num} Dupe QSOs identified during final check\n."
  m = Multiplier.new(db, contestID, contestDB)
  print "Resolving DX\n"
  m.resolveDX
  print "Resolving bye multipliers\n"
  m.checkByeMultipliers
  print "Filling in comments\n"
  fillInComment(db, contestID)
  r = Report.new(db, contestID)
  print "Making report\n"
  open("scores_" + $name.gsub(/\s+/,"_") + "_" + $year.to_s + ".csv", "w:ascii") { |out|
    r.makeReport(out)
  }
  print "Dumping logs\n"
  dumpLogs(db, contestID)
  print "All Done\n"
end

begin
  if $name and $year and [:load, :score, :checkdupes ].include?($action)
    db = makeDB(dbopts)
    cdb = ContestDatabase.new(db, ct)
    contestID = cdb.addOrLookupContest($name, $year, $create)
    if not contestID
      print "Unknown contest #{$name} #{$year}\n"
      db.close
      exit 2
    end
  else
    db = nil
    cdb = nil
    if [:load, :score, :checkdupes ].include?($action)
      print "Load and score action require a database.\n"
      exit 2
    end
  end  
  case $action
  when :load, :check
    loadFiles(ARGV, cdb, contestID, ct)
  when :score
    scoreContest(db, contestID, cdb)
  when :checkdupes
    if cdb and contestID
      cdb.checkDupeLogs(contestID)
    else
      $stderr.write("Check dupes requires a database and contest ID.\n")
    end
  end
  print "Done...shutting down\n"
  $stdout.flush
rescue
  print "Exception thrown"
  $stdout.flush
  $stderr.print "Exception: " + $!.to_s + "\n"
  $stderr.print $!.backtrace.join("\n")
ensure
  if db 
    db.close
  end
end

